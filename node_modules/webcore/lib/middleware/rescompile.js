var url = require('url'),
	path = require('path'),
	fs = require('fs'),
	fsutil = require('../fsutil'),
	util = require('util'),
	DustCompiler = require('../resource/dustCompiler'),
	LessCompiler = require('../resource/lessCompiler'),
	FileCopier = require('../resource/fileCopier');



/**
 *
 * @param src
 * @param dest
 * @returns
 */
function buildProcessorChain(src, dest) {
	var dustCompiler = new DustCompiler(src, dest),
		lessCompiler = new LessCompiler(src, dest, dustCompiler),
		copier = new FileCopier(src, dest, lessCompiler);

	return copier;
}


/**
 *
 * @param dir
 */
function empty(dir) {
	try {
		// Clear dest directory before starting
		fsutil.rmdirfSync(dir);
	} catch (err) {
		// Don't really care if the file doesn't exist, but other errors may be bad
		if (err.code !== 'ENOENT') {
			throw err;
		}
	}
}

/**
 *
 * @param src
 * @param dest
 * @param processor
 * @param callback
 */
function precompile(src, dest, processor, callback) {
	var files = [];

	function dirIter(dir, next) {
		next();
	}

	function fileIter(file, next) {
		var rel = path.relative(src, file);
		files.push(rel);
		processor.run(rel, next);
	}

	fsutil.forEach(src, dirIter, fileIter, function(err) {
		callback(err, files);
	});
}

/**
 *
 * @param src
 * @param dest
 * @param callback
 */
function aggregate(src, dest, callback) {
	var files = [];

	function dirIter(dir, next) {
		next();
	}

	function fileIter(file, next) {
		var rel = path.relative(src, file);
		files.push(rel);
		next();
	}

	fsutil.forEach(src, dirIter, fileIter, function(err) {
		callback(err, files);
	});
}

/**
 * Public API
 *
 *     compile(options, callback):Void
 *
 * Registers middleware or pre-process resources
 * @param {Object} options the options to use when setting up this middleware
 * @param {Function} [callback] continuation and flag to trigger pre-compile mode
 * @return the middleware implementation or undefined
 */
module.exports = {
	/**
	 *
	 * @param options
	 * @param callback
	 */
	compile: function(options, callback) {

		var src = options.src || process.cwd(),
			dest = options.dest || src,
			processor = buildProcessorChain(src, dest);

		// Unfortunately have to set a global for less
		resourceRoot = src;
		empty(dest);

		precompile(src, dest, processor, function(err, files) {
			callback(err);
		});

	},

	resourceCompiler: function(options) {

		var src = options.src || process.cwd(),
			dest = options.dest || src,
			processor = buildProcessorChain(src, dest),
			files = [];

		// Unfortunately have to set a global for less
		resourceRoot = src;
		empty(dest);

		aggregate(src, dest, function(err, foundFiles) {
			files = foundFiles;
		});

		return function(req, res, next) {
			var pathname = null,
				src = null,
				exists = false;

			if (req.method !== 'GET') {
				return next();
			}

			pathname = url.parse(req.url).pathname;
			if (pathname[pathname.length - 1] === '/') {
				// index.html support (see connect.js)
				pathname += 'index.html';
			}

			// Ensure request path is converted to appropriate OS file path
			pathname = path.join.apply(null, pathname.split('/'));

			exists = files.some(function(file) {
				// See if the file is just a raw, non-compiled, file (e.g. css, not less)
				src = file;
				return pathname.indexOf(file) !== -1;
			});

			if (!exists) {
				// File needs tp be compiled, so look for a matching source file
				// TODO - This isn't strict enough and may allow non-exact matches through
				exists = files.some(function(file) {
					src = file;
					var pathBase = pathname.replace(path.extname(pathname), ''),
						fileBase = file.replace(path.extname(file), '');
					// Omit the leading slash on pathBase
					return pathBase === fileBase;
				});
			}

			// If a source file was found, use it, otherwise pass the raw pathname along.
			processor.run(exists ? src : pathname, next);
		};
	}
};


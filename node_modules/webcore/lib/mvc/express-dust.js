/**
 * Software License Agreement (BSD License)
 *
 * Copyright (c) 2011, Dav Glass <davglass@gmail.com>.
 * All rights reserved.
 *
 * Redistribution and use of this software in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above
 *   copyright notice, this list of conditions and the
 *   following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above
 *   copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other
 *   materials provided with the distribution.
 *
 * * The name of Dav Glass may not be used to endorse or promote products
 *   derived from this software without specific prior
 *   written permission of Dav Glass.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
var fs = require('fs'),
    fsPath = require('path'),
    http = require('http'),
    dust = require('dustjs-linkedin'),
    config = require('../config'),
    baseContext = dust.makeBase({}),
    exists = fs.exists || fsPath.exists;

var mix = function(dest /*, src... */) {
    Array.prototype.slice.call(arguments, 1).forEach(function (src) {
        Object.keys(src).forEach(function (prop) {
            var descriptor = Object.getOwnPropertyDescriptor(src, prop);
            Object.defineProperty(dest, prop, descriptor);
        });
    });
    return dest;
};


module.exports = {
    filters : dust.filters,
    makeBase: function(obj) {
        baseContext = dust.makeBase(mix(baseContext.global, obj));
        return baseContext;
    }
};

dust.onLoad = function(name, callback) {
    var root = config.get('paths:viewPath') || fsPath.join(process.cwd(), 'views');
    name = name.replace(/\.dust$/, '') + '.dust';
    fs.readFile(fsPath.join(root, name), 'utf8', callback);
};


//This needs a setter TODO
// Disable whitespace compression.
dust.optimizers.format = function (context, node) {
    return node;
};

// Duckpunch Express's res.render() method to use Dust. This is necessary
// because Express doesn't support async template engines by default.
http.ServerResponse.prototype.render = function (view, options, callback) {
    var res = this,
        locals = null,
        context = null,
        base = {};

    // options could've been null or undefined
    options = options || {};

    // Support callback as second arg.
    if (typeof options === 'function') {
        callback = options;
        options = {};
    }

    callback = callback || function(err, html) {
        if (err) { res.req.next(err); return; }
        res.send(html);
    };


    // Wrap with the master page
    options._main = view;
    view = options.master || 'inc/master';

    // Ugh. Sparta shim.
    if (options.content) {
        // content exists, so hoist above other options
        base.cn = options.content;
        delete options.content;
    }

    // Push provided data onto context
    context = dust.makeBase(mix(base, baseContext.global));
    context = context.push(options);


    // Support the case when res.locals is implemented as a getter vs.
    // a direct object reference.
    locals = (typeof res.locals === 'function') ? res._locals : res.locals;
    if (locals) {
        context = context.push(locals);
}

    // TODO: Figure out a good way to catch parser errors. Currently Dust's
    // parser just throws them instead of passing them to the callback.
    // See https://github.com/akdubya/dustjs/issues#issue/12
    if (__devenv) {
        dust.cache = {}; // Reflect template changes without a restart.
        dust.onLoad(view, function (err, content) {
            if (err) { res.req.next(err); return; }
            dust.renderSource(content, context, callback);
        });
    } else {
        dust.render(view, context, callback);
    }
};

http.ServerResponse.prototype.partial = function (view, options, callback) {
    var res = this,
        req = this.req,
        header = '',
        ct = req.headers['content-type'],
        setHeader = false;

    // Support callback as second arg.
    if (typeof options === 'function') {
        callback = options;
        options  = {};
    }
    if (!callback) {
        setHeader = true;
    }

    var root = config.get('paths:viewPath') || fsPath.join(process.cwd(), 'views'),
        part = fsPath.join(root, 'partials', view + '.dust');

    callback || (callback = function (err, html) {
        if (err) { res.req.next(err); return; }
        res.send(html);
    });
    exists(part, function(x) {
        if (x) {
            res.render('partials/' + view, function(err, html) {
                if (err) {
                    callback(err);
                    return;
                }
                var data = html;
                if (setHeader) {
                    if (ct && ct.indexOf(';') > 0) {
                        ct = ct.split(';')[0];
                    }
                    switch (ct) {
                        case 'application/json':
                        case 'text/javascript':
                            header = '.json';
                            data = { html: html };
                            break;
                        case 'text/plain':
                            header = '.txt';
                            break;
                        default:
                            header = '.html';
                            break;
                    }
                    res.contentType(header);
                }
                callback(null, data);
            });

        } else {
            callback({ error: 'Not Found' });
        }
    });

};

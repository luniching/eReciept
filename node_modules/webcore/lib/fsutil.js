var fs = require("fs"),
	path = require("path"),
	util = require("util"),
	async = require('async'),
	mkdirp = require('mkdirp');


module.exports = {
	isempty: isempty,
	isemptySync: isemptySync,

	copy: copy,
	copySync: copySync,

//	move: move,
//	moveSync: moveSync,

	copydir: copydir,
	copydirSync: copydirSync,

	mkdir: mkdir,
	mkdirSync: mkdirSync,

	rmdirf: rmdirf,
	rmdirfSync: rmdirfSync,

	forEach: forEach
};

/**
 * Determines whether or not a folder is empty.
 * @param {String} dir the path of the directory to check
 * @param {Function} fn the callback to invoke with the result
 */
function isempty(dir, fn) {
	fs.readdir(dir, function(err, files) {
		if (err && err.code !== 'ENOENT') {
			fn(err);
			return;
		}
		fn(null, !files || !files.length);
	});
}

/**
 * Determines whether or not a folder is empty.
 * @param {String} dir the path of the directory to check
 */
function isemptySync(dir) {
	return !fs.readdirSync(dir).length;
}

/**
 *
 * @param src
 * @param dest
 * @param fn
 */
function copy(src, dest, fn) {
	'use strict';
	fn = fn || function() {};

	fs.stat(src, function(err, stats) {
		if (err) { return fn(err); }

		if (!stats.isFile()) {
			return fn(new Error('Source is not a file: ' + src));
		}

		mkdir(path.dirname(dest), function (err) {
			if (err) { return fn(err); }

			var is = fs.createReadStream(src),
				os = fs.createWriteStream(dest);

			util.pump(is, os, function (err) {
				// Pump returns more than just the error object
				// so call the callback explicitly.
				fn(err);
			});
		});
	});
}


/**
 *
 * @param src
 * @param dest
 */
function copySync(src, dest) {
	throw new Error('not implemented');
}

/**
 * Copies the contents of the specified dir into the dest dir, creating the
 * dest dir if necessary.
 * @param src
 * @param dest
 * @param callback
 */
function copydir(src, dest, fn) {
	'use strict';

	src = path.resolve(src);
	dest = path.resolve(dest);

	/**
	 *
	 */
	function processDir(dir, next) {
		if (src === dir) { return next(); }
		var rel = path.relative(src, dir);
		copydir(path.join(src, rel), path.join(dest, rel), next);
	}

	/**
	 *
	 */
	function processFile(file, next) {
		var rel = path.relative(src, file);
		copy(path.join(src, rel), path.join(dest, rel), next);
	}

	mkdir(dest, function(err) {
		if (err) { return fn(err); }
		fs.stat(src, function(err, stats) {
			if (err) { return fn(err); }

			if (!stats.isDirectory()) {
				return fn(new Error('Source is not a directory: ' + src));
			}

			forEach(src, processDir, processFile, fn);
		});
	});
}


/**
 *
 * @param src
 * @param dest
 */
function copydirSync(src, dest) {
	throw new Error('not implemented');
}



/**
 * Creates a directory with the appropriate permissions.
 * @param {String} dir the directory to be created
 * @param {Function} fn the callback to invoke when the specified directory is created
 */
function mkdir(dir, fn) {
	mkdirp(dir, parseInt('755', 8), fn);
}



/**
 *
 * @param dir
 * @returns
 */
function mkdirSync(dir) {
	return mkdirp.sync(dir, parseInt('755', 8));
}



/**
 * @param {String} dir
 * @param {boolean} force
 * @param {Function} callback
 */
function rmdirf(dir, callback) {
	'use strict';

	// XXX: Experimental
	// Er, we don't want people passing '/' so we'll protected against
	// trying to delete root.
	if(dir === '/') {
		return callback(new Error('dude. no.'));
	}

	forEach(dir, fs.rmdir, fs.unlink, callback || function() {});
}



/**
 * @param {String} dir
 * @param {boolean} force
 */
function rmdirfSync(dir) {
	'use strict';

	var files = fs.readdirSync(dir),
		file  = null,
		stats = null;

	while (files.length) {
		file = path.join(dir, files.shift());
		stats = fs.statSync(file);

		if (stats.isDirectory()) {
			rmdirfSync(file);
		}
		else if (stats.isFile()) {
			fs.unlinkSync(file);
		}
	}

	fs.rmdir(dir);
}


/**
 *
 * @param dir
 * @param dirIterator
 * @param fileIterator
 * @param callback
 */
function forEach(dir, dirIterator, fileIterator, callback) {
	'use strict';

	fs.readdir(dir, function(err, files) {
		if (err) { return callback(err); }

		var file = null,
			remaining = files.length,
			tasks = [];

		if (!remaining) {
			dirIterator(dir, callback);
			return;
		}

		function onStat(file) {
			return function(err, stats) {

				var task = null;

				if (stats.isDirectory()) {
					task = function(next) {
						// Descend
						forEach(file, dirIterator, fileIterator, next);
					};
				}
				else if (stats.isFile()) {
					task = function(next) {
						// Process
						fileIterator(file, next);
					};
				}

				task && tasks.push(task);

				if (!--remaining) {
					// All files have been evaluated, so start processing
					async.waterfall(tasks, function(err) {
						if (err) { return callback(err); }
						dirIterator(dir, callback);
					});
				}
			};
		}

		while (files.length) {
			file = path.join(dir, files.shift());

			fs.stat(file, onStat(file));
		}
	});
}

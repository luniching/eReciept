'use strict';

var fs = require('fs'),
    path = require('path'),
    less = require('less'),
    mkdirp = require('mkdirp'),
    dustjs = require('express-dustjs');


function noop(req, res, next) {
    next();
}


var handlers = [
    {
        name: 'dust',
        pattern: /^\/templates\/(.*)\.js$/,
        compiler: {
            compile: function (name, src, options, callback) {
                callback(null, dustjs.compile(src.toString('utf8'), name));
            }
        }
    },
    {
        name: 'less',
        pattern: /^\/css\/(.*)\.css$/,
        compiler: {
            compile: function (name, src, options, callback) {
                var parser = new(less.Parser)({
                    paths: options.paths, // Specify search paths for @import directives
                    filename: name // Specify a filename, for better error messages
                });

                parser.parse(src.toString('utf8'), function (err, tree) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    callback(null, tree.toCSS());
                });
            }
        }
    },
    {
        name: 'js',
        pattern: /^\/js\/(.*)\.js$/,
        compiler: {
            compile: function (name, source, options, callback) {
                // TODO: r.js?
                callback(null, source);
            }
        }
    },
    {
        name: 'copier',
        pattern: /.*/,
        compiler: {
            compile: function (name, source, options, callback) {
                callback(null, source);
            }
        }
    }
];


function process(handler, file, srcRoot, staticRoot, next) {
    var name, srcFile, destFile, srcPath, destPath;

    srcFile = destFile = file.replace('/', path.sep);
    if (handler.name !== 'copier') {
        srcFile = srcFile.replace(path.extname(srcFile), '') + '.' + handler.name;
    }

    srcPath = path.join(srcRoot, srcFile);
    destPath = path.join(staticRoot, destFile);

    fs.readFile(srcPath, function (err, data) {
        var dirs, dir;

        if (err) {
            next(err);
            return;
        }

        // Build search paths for compilers.
        dirs = [];
        dir = path.dirname(srcPath);
        while (dir !== srcRoot) {
            dirs.unshift(dir);
            dir = path.dirname(dir);
        }

        handler.compiler.compile(name[1], data, { paths: dirs }, function (err, result) {
            mkdirp(path.dirname(destPath), function (err) {
                if (err) {
                    next(err);
                    return;
                }
                fs.writeFile(destPath, result, next);
            });
        });

    });
}


exports.compiler = function (srcRoot, staticRoot) {

    return function (req, res, next) {
        var handler, name, srcFile, destFile, srcPath, destPath;

        if (req.method.toLowerCase() !== 'get') {
            next();
            return;
        }

        handlers.some(function (item) {
            handler = item;
            name = item.pattern.exec(req.path);
            return !!name;
        });

        srcFile = destFile = req.path.replace('/', path.sep);
        if (handler.name !== 'copier') {
            srcFile = srcFile.replace(path.extname(srcFile), '') + '.' + handler.name;
        }

        srcPath = path.join(srcRoot, srcFile);
        destPath = path.join(staticRoot, destFile);

        fs.readFile(srcPath, function (err, data) {
            var dirs, dir;

            if (err) {
                next(err);
                return;
            }

            // Build search paths for compilers.
            dirs = [];
            dir = path.dirname(srcPath);
            while (dir !== srcRoot) {
                dirs.unshift(dir);
                dir = path.dirname(dir);
            }

            handler.compiler.compile(name[1], data, { paths: dirs }, function (err, result) {
                mkdirp(path.dirname(destPath), function (err) {
                    if (err) {
                        next(err);
                        return;
                    }
                    fs.writeFile(destPath, result, next);
                });
            });

        });
    }
};


exports.dust = function (options, staticRoot) {

    var lib;

    if (!options || !options.srcRoot) {
        return noop;
    }

    try {
        lib = require('dustjs-linkedin');
    } catch (err) {
        try {
            lib = require('express-dustjs');
        } catch (err) {
            throw new Error('No dust.js module found.');
        }
    }

    function compiler(name, src, options, callback) {
        var error = null, result;
        try {
            result = lib.compile(src.toString('utf8'), name);
        } catch (err) {
            error = err;
        }
        callback(error, result);
    }

    var handler = {
        name: 'dust',
        compiler: { compile: compiler }
    };

    return function (req, res, next) {
        process(handler, req.path, options.srcRoot, staticRoot, next);
    }

};

exports.less = function (path, srcRoot, staticRoot) {

    var lib;

    try {
        lib = require('less');
    } catch (err) {
        throw new Error('No less module found.');
    }

    function compiler(name, src, options, callback) {
        var parser = new(lib.Parser)({
            paths: options.paths, // Specify search paths for @import directives
            filename: name        // Specify a filename, for better error messages
        });

        parser.parse(src.toString('utf8'), function (err, tree) {
            if (err) {
                callback(err);
                return;
            }
            callback(null, tree.toCSS());
        });
    }

    var handler = {
        name: 'less',
        compiler: { compile: compiler }
    };

    return function (req, res, next) {
        if (req.path.match(route)) {
            process(handler, req.path, srcRoot, staticRoot, next);
        } else {
            next();
        }
    }

};


exports.default = function (options, staticRoot) {

    if (!options || !options.srcRoot) {
        return noop;
    }

    function handler(name, src, options, callback) {
        callback(null, src);
    }

    return function (req, res, next) {
        process(handler, req.path, options.srcRoot, staticRoot, next);
    }

};

exports.compile = function (options, staticRoot) {
    var middleware;

    if (!options || !options.srcRoot) {
        return noop;
    }

    middleware = [{
        route: '(.*}',
        handler: exports.default
    }];

    Object.keys(options.paths).forEach(function (path) {
        middleware.unshift({
            route: path,
            handler: exports[options.paths[path]](path, options.srcRoot, staticRoot)
        });
    });

    return function (req, res, next) {
        var handler;

        middleware.some(function (def) {
            handler = def.handler;
            return !!req.path.match(def.route);
        });

        handler(req, res, next);
    }
};



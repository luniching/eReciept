'use strict';


var fs = require('fs'),
    path = require('path'),
    tater = require('tater'),
    resolver = require('./lib/resolver');


/**
 *
 * @param app
 * @param engine
 * @param config Object { fallback: '' }
 */
exports.patchExpress = function (app, config) {
    var ext, root, render, templateResolver;

    config = config || {};
    ext = app.get('view engine');
    root = app.get('views');

    // Apply for compiled templates and when express isn't already patched.
    if (ext === 'js' && app.render.name !== 'clobbered') {
        render = app.render;
        templateResolver = resolver.create({ root: root, fallback: config.fallback, ext: ext });

        // XXX - This is an awful hack.
        app.render = function clobbered(view, options, fn) {
            var file;

            // Reset root
            app.set('views', root);

            file = templateResolver.resolve(view, options._locals);
            if (file) {
                // We update the view root *only* for the call to app.render.
                // It only works because the part that resolves the view path is synchronous
                // and once we get past that check our own code can take over.
                app.set('views', path.dirname(file));
            }

            render.apply(this, arguments);
        };

    }
};



//exports.engine = function (ext, engine, config) {
//    var impl;
//
//    if (ext[0] === '.') {
//        ext = ext.slice(1);
//    }
//
//    impl = exports[ext];
//    impl && impl(ext, engine, config);
//};
//
//
//
//exports.dust = function (ext, engine, config) {
//
//    var resolveContent = createFallbackResolver({ root: config.contentPath, ext: 'properties' });
//
//    function resolveTemplate(file, context) {
//        var views = context.views || (context.settings && context.settings.views);
//        return path.join(views, file + '.' + ext);
//    }
//
//    engine.onLoad = function (file, context, cb) {
//        var handler, bundle;
//
//        handler = {
//            tags: 'pre',
//            onTag: function (def, cb) {
//                return 'Lorem Ipsum';
//            }
//        };
//
//        bundle = resolveContent(file, context);
//        if (!bundle) {
//            // TODO: Inject nonsense for found tags.
//            fs.readFile(resolveTemplate(file, context), 'utf8', cb);
//            return;
//        }
//
//        tater.deserialize(fs.createReadStream(bundle), 'properties', function (err, content) {
//            if (err) {
//                cb(err);
//                return;
//            }
//
//            handler.onTag = function (def, cb) {
//                var key, value;
//
//                key = def.attributes.key.split('.');
//                value = content;
//
//                while (value && key.length) {
//                    value = value[key.shift()];
//                }
//
//                cb(null, String(value));
//            };
//
//            finder.parse(resolveTemplate(file, context), handler, cb);
//        });
//    };
//
//};
//
//
//exports.js = function (ext, engine, config) {
//    engine.onLoad = function (file, context, cb) {
//        var root, resolve;
//        root = context.views || (context.settings && context.settings.views);
//        resolve = createFallbackResolver({ root: root, ext: ext });
//        fs.readFile(resolve(file, context), 'utf8', cb);
//    };
//};



//exports.process = function (file, contentRoot, cb) {
//    finder.process(file, handler, cb);
//};
//
//
//exports.createReadStream = function (file, contentRoot) {
//    return fs.createReadStream(file).pipe(finder.createParseStream(handler));
//};




'use strict';


var fs = require('fs'),
    path = require('path'),
    tater = require('tater'),
    finder = require('tagfinder'),
    cache = require('./lib/cache'),
    handler = require('./lib/handler'),
    resolver = require('./lib/resolver');


var TEMPLATE_CACHE;

function initEngine(ext, engine, config) {
    var impl;

    if (ext[0] === '.') {
        ext = ext.slice(1);
    }

    impl = exports[ext];
    impl && impl(ext, engine, config);
}



exports.init = function (app, engine, config) {
    var ext, root, render, fileResolver;

    if (!config) {
        return;
    }

    ext = app.get('view engine');
    root = app.get('views');

    if (config.cache) {
        // If caching is enabled, we secretly switch express to use the 'js'
        // rendering engine so we can cache the compiled templates.
        app.engine(ext, engine.js({ cache: false }));
    }

    // Only apply for precompiled templates and unpatched express.
    if (ext === 'js' && app.render.name !== 'clobbered') {
        render = app.render;
        fileResolver = resolver.create({ root: root, ext: ext, fallback: config.fallback });

        // XXX - This is an awful hack.
        app.render = function clobbered(view, options, fn) {
            var file;

            // Reset root
            app.set('views', root);

            file = fileResolver.resolve(view, options._locals.context.locality);
            if (file) {
                // We update the view root *only* for the call to app.render.
                // It only works because the part that resolves the view path is synchronous
                // and once we get past that check our own code can take over.
                app.set('views', path.dirname(file));
            }

            render.apply(this, arguments);
        };

    }

    initEngine(ext, engine, config);
};



exports.dust = function (ext, engine, config) {
    var bundles, createTemplatePath;

    bundles = resolver.create({ root: config.contentPath, ext: 'properties', fallback: config.fallback });
    createTemplatePath = function (file, context) {
        var global, views;
        global = context.global;
        views = global.views || (global.settings && global.settings.views);
        return path.join(views, file + '.' + ext);
    };

    engine.onLoad = function (file, context, callback) {
        var template, locals, bundle;

        template = createTemplatePath(file, context);
        locals = context.get('context');
        bundle = bundles.resolve(file, locals && locals.locality);

        finder.parse(template, handler.create(bundle), callback);
    };

    TEMPLATE_CACHE = cache.create(engine, config);
    if (TEMPLATE_CACHE.enabled) {
        TEMPLATE_CACHE.dataProvider = engine.onLoad;
        engine.onLoad = TEMPLATE_CACHE.get.bind(TEMPLATE_CACHE);
    }
};


exports.js = function (ext, engine, config) {
    engine.onLoad = function (file, context, cb) {
        var global, root, fileResolver, locals, filePath;

        global = context.global;
        root = global.views || (global.settings && global.settings.views);
        fileResolver = resolver.create({ root: root, ext: ext, fallback: config.fallback });

        locals = context.get('context');
        filePath = fileResolver.resolve(file, locals && locals.locality);

        if (!filePath) {
            cb(new Error('Could not load template ' + file));
            return;
        }

        fs.readFile(filePath, 'utf8', cb);
    };

    TEMPLATE_CACHE = cache.create(config);
    if (TEMPLATE_CACHE.enabled) {
        TEMPLATE_CACHE.dataProvider = engine.onLoad;
        engine.onLoad = TEMPLATE_CACHE.get.bind(TEMPLATE_CACHE);
    }
};


exports.__defineGetter__('cache', function () {
    return TEMPLATE_CACHE;
});

'use strict';

var util = require('util'),
	sax = require('sax'),
	Node = require('./node');



var V4Reader = module.exports = function V4Reader() {
    this._parser = undefined;
    this._deserialized = undefined;
    this._currentNode = undefined;

	var parser = this._parser = sax.parser(true);
	parser.ontext = this._onText.bind(this);
	parser.onopentag = this._onOpenTag.bind(this);
	parser.onclosetag = this._onCloseTag.bind(this);

	this._init();
};

V4Reader.prototype = {

	_init: function () {
		this._deserialized = {};
		this._currentNode = new Node(null, null, null, this._deserialized);
	},

	_doDeserialize: function(data, callback) {

		this._parser.onerror = function (err) {
			process.nextTick(function () {
				callback(err);
			});
			this._init();
		}.bind(this);

		this._parser.onend = function () {
			var deserialized = this._deserialized;
			process.nextTick(function () {
				callback(null, deserialized);
			});
			this._init();
		}.bind(this);

		this._parser.write(data).close();

	},

	_onText: function (text) {
		var node = this._currentNode,
			parent = null;

		if (node) {
			if (!node.data) {
				parent = node.parent;
				if (parent && parent.type === 'ContentList') {
					// This is an ugly hack for a nonsensical ContentList implementation,
					// where children ContentElements of ContentLists get this weird
					// datastructure
					parent.data.push( { '$id' : node.name, '$elt' : text } );
					delete parent.data[node.name];
				} else {
					// BASE CASE: The data/content of the element is set.
					node.data = text;
				}

			} else if (typeof node.data === 'string') {
				// Working through DPH or the like, so concat new text node.
				node.data += text;

			} else if (Array.isArray(node.data)) {
				// noop - Probably a ContentList, so just move on to descend to children
			}
		}
	},

	_onOpenTag: function (node) {
		switch (node.name) {
			case 'ContentBundle':
				var ns = node.attributes.instanceOf.split('.');
				ns.forEach(function (packageName) {
					this._currentNode = new Node(packageName, node.name, this._currentNode, {});
				}.bind(this));
				break;

			case 'DPH':
				this._onText('{' + node.attributes.id + '}');
				this._currentNode = new Node(node.attributes.id, node.name, this._currentNode);
				break;

			case 'ContentElement':
				this._currentNode = new Node(node.attributes.id, node.name, this._currentNode);
				break;

			case 'ContentList':
				this._currentNode = new Node(node.attributes.id, node.name, this._currentNode, []);
				break;

			case 'ContentStructure':
				// XXX: Intentionally fall through
				// I refuse to treat ContentStructure and ContentMap differently. They are fundamentally the same
				// even though ContentMap can only have ContentElement children and ContentStructure "is similar
				// to the map content. The difference is that the elements can be any content type."
			case 'ContentMap':
				this._currentNode = new Node(node.attributes.id, node.name, this._currentNode, {});
				break;
		}
	},

	_onCloseTag: function (name) {
		if (this._currentNode && this._currentNode.type === name) {
			this._currentNode = this._currentNode.parent;
		}
	}

};


